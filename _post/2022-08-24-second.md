
## 그리디

### 거스름돈
예제
* 당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.

문제 해설
* 이 문제는 그리디 알고리즘을 이용해 풀 수 있는 대표적인 문제로 간단한 아이디어만 떠올릴 수 있으면 문제를 해결할 수 있다. 그것은 바로 '가장 큰 화폐 단위'부터 돈을 거슬러 주는 것이다. N원을 거슬러 줘야 할 때, 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 준다. 그다음 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러 주면 최소의 동전 개수로 모두 거슬러 줄 수 있다.


```python
def coin_count(n):
    count = 0
    coin_types = [500, 100, 50, 10]
    for coin in coin_types:
        count += n//coin
        n %= coin
    return count

print(coin_count(1260))
```

    6
    

### 큰 수의 법칙

문제
* '큰 수의 법칙'은 일반적으로 통계 분야에서 다루어 지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 잇다. 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.

* 예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.

* 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 예를 들어 순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을 때 M이 7이고, K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4인 28이 도출된다.

* 배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.

입력조건

* 첫째 줄에 N(2<=N<=1000), M(1<=M<=10000), K(1<=K<=10000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.

* 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10000이하의 수로 주어진다.

* 입력으로 주어지는 K는 항상 M보다 작거나 같다.

출력조건

* 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

입력예시

``` 
    5 8 3
    2 4 5 4 6 
```
       
출력예시

``` 
    46 
```

* 문제 해설: 이 문제를 해결하려면 일단 입력값 중에서 가장 큰 수와 두 번째로 큰 수만 저장하면 된다. 연속으로 더할 수 있는 횟수는 최대 K번이므로 '가장 큰 수를 K번 더하고 두 번째로 큰 수를 한 번 더하는 연산'을 반복하면 된다.


```python
def max_number(data,n,m,k):
    result = 0
    
    data.sort() # 입력받은 수들 정렬하기
    first = data[n-1] # 가장 큰 수
    second = data[n-2] # 두 번째로 큰 수
    
    while True:
        for i in range(k): # 가장 큰 수를 K번 더하기
            if m == 0: # m이 0이라면 반복문 탈출
                break
            else:
                result += first
                m -= 1 # 더할 때마다 1씩 빼기
        if m == 0: # m이 0이라면 반복문 탈출
            break
        else:
            result += second # 두 번째로 큰 수를 한 번 더하기
            m -= 1 # 더할 때마다 1씩 빼기
    return result

print(max_number([2,4,5,4,6],5,8,3))
print(max_number([3,4,3,4,3],5,7,2))
```

    46
    28
    

### 1이 될 때까지

문제
* 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.

```
1. N에서 1을 뺀다.
2. N을 K로 나눈다.
```

* 예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다. 이는 N을 1로 만드는 최소 횟수이다.
* N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행하야 하는 최소 횟수를 구하는 프로그램을 작성하시오.

입력조건
* 첫째 줄에 N(2<=N<=1000000)과 K(2<=K<=100000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.

출력조건 
* 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.

입력 예시
```
25 5
```

출력 예시
```
2
```

문제 해설
* 주어진 N에 대하여 '최대한 많이 나누기'를 수행하면 된다. 왜냐하면 어떠한 수가 있을 때, '2 이상의 수로 나누는 것'이 '1을 빼는 것'보다 숫자를 훨씬 많이 줄일 수 있기 때문이다. 문제에서는 K가 2 이상의 자연수이므로, 가능하면 나누는 것이 항상 더 숫자를 빠르게 줄이는 방법이 된다.
* 예를 들어 N이 9일때 K가 3이라면 2번만 나누어도 순식간에 N=9에서 N=1이 된다. 그러므로 매우 빠르게 1을 만들 수 있다. 반면에 N=9일때 1을 빼는 방식만을 이용하면 8번을 빼야지만 N=1을 만들 수 있다. 따라서 다음의 과정을 반복할 수 없을 때까지 반복하면 정답을 구할 수 있다.

```
1. N이 K의 배수가 될 때까지 1씩 빼기
2. N을 K로 나누기
```


```python
def number_one(n, k):
    result = 0
    while n>=k:
        while n % k != 0 :
            n -= 1
            result += 1
        n //= k
        result += 1
    
    while n > 1:
        n -= 1
        result += 1
    return result

print(number_one(25,5))
```

    2
    

### 곱하기 혹은 더하기: 문제 조건

문제
* 각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+'연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요. 단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.
* 예를 들어 02984라는 문자열로 만들 수 있는 가장 큰 수는 (((0+2)x9)x8)x4)=576입니다. 또한, 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어집니다.

입력 조건
* 첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어집니다.(1 <= S의 길이 <= 20)

출력 조건
* 첫째 줄에 만들어질 수 있는 가장 큰 수를 출력합니다.

입력 예시 1
```
02984
```
출력 예시 1
```
576
```
입력 예시 2
```
567
```
출력 예시 2
```
210
```

문제 해결
* 대부분의 경우 '+'보다는 'x'가 더 값을 크게 만듭니다. 예를 들어 5+6=11이고, 5x6=30입니다.
* 다만 두 수 중에서 하나라도 '0' 혹은 '1'인 경우, 곱하기보다는 더하기를 수행하는 것이 효율적입니다. 따라서 두 수에 대하여 연산을 수행할 때, 두 수 중에서 하나라도 1 이하인 경우에는 더하며, 두 수가 모두 2이상인 경우에는 곱하면 정답입니다.


```python
def number(data):
    # 첫 번째 문자를 숫자로 변경하여 대입
    result = int(data[0])
    
    for i in range(1,len(data)):
        # 두 수 중에서 하나라도 '0' 혹은 '1'인 경우, 곱하기보다는 더하기 수행
        num = int(data[i])
        if num <= 1 or result <= 1:
            result += num
        else:
            result *= num
    return result

print(number('02984'))
print(number('567'))
```

    576
    210
    

### 모험가 길드

문제
* 한 마을에 모험가가 N명 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다.
* 모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다.
* 동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다. N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 잇는 그룹 수의 최댓값을 구하는 프로그램을 작성하세요.
* 예를 들어 N = 5이고, 각 모험가의 공포도가 다음과 같다고 가정합시다.

```
2 3 1 2 2
```

* 이 경우 그룹 1에 공포도가 1,2,3인 모험가를 한 명씩 넣고, 그룹 2에 공포도가 2인 남은 두 명을 넣게 되면 총 2개의 그룹을 만들 수 있습니다.
* 또한 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없습니다.

입력 조건
* 첫째 줄에 모험가의 수 N이 주어집니다.(1 <= N <= 100000)
* 둘째 줄에 각 모험가의 공포도의 값을 N 이하의 자연수로 주어지며, 각 자연수는 공백으로 구분합니다.

출력 조건
* 여행을 떠날 수 있는 그룹 수의 최댓값을 출력합니다.

입력 예시
```
5
2 3 1 2 2 
```

출력 예시
```
2
```

문제 해결
* 오름차순 정렬 이후에 공포도가 가장 낮은 모험가부터 하나씩 확인합니다.
* 앞에서부터 공포도를 하나씩 확인하며 '현재 그룹에 포함된 모험가의 수'가 '현재 확인하고 있는 공포도'보다 크거나 같다면 이를 그룹으로 설정하면 됩니다.
* 이러한 방법을 이용하면 공포도가 오름차순으로 정렬되어 있다는 점에서, 항상 최소한의 모험가의 수만 포함하여 그룹을 결성하게 됩니다.


```python
def ghost(n,data):
    data.sort()
    result = 0 # 총 그룹의 수
    count = 0 # 현재 그룹에 포함된 모험가의 수
    
    for i in data: # 공포도를 낮은 것부터 하나씩 확인하며
        count += 1 # 현재 그룹에 해당 모험가를 포함시키기
        if count >= i: # 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면, 그룹 결성
            result += 1 # 총 그룹의 수 증가시키기
            count = 0 # 현재 그룹에 포함된 모험가의 수 초기화
    return result

print(ghost(5, [2,3,1,2,2]))
```

    2
    


```python

```
